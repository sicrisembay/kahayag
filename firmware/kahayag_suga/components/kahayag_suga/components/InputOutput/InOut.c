/*$file${components::InputOutput::.::InOut.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: kahayag_suga.qm
* File:  ${components::InputOutput::.::InOut.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${components::InputOutput::.::InOut.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "signalList.h"
#include "priorityList.h"
#include "InOut.h"
#include "driver/gpio.h"
#include "SysMngt.h"

Q_DEFINE_THIS_FILE

const static uint32_t const INPUT_IO[N_INPUT_ID] = {
    5    /* GPIO_0 */
};

const static uint8_t const INPUT_DEBOUNCE_THRES[N_INPUT_ID] = {
    5,    /* 5 * INOUT_TICK_INTERVAL_MS */
};

#define IO_DEBOUNCE_MASK(x)    ((uint32_t)((1ULL << x) - 1))

/*$declare${components::InputOutput::InOut} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::InputOutput::InOut} ........................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt tickTimeEvt;
    uint32_t debouncer[N_INPUT_ID];
    bool inputState[N_INPUT_ID];
} InOut;

/* protected: */
static QState InOut_initial(InOut * const me, QEvt const * const e);
static QState InOut_TOP(InOut * const me, QEvt const * const e);
/*$enddecl${components::InputOutput::InOut} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Local Object */
static InOut l_InOut;
/* FreeRTOS stack for AO */
static StackType_t inOutStack[2*configIDLE_TASK_STACK_SIZE];
/* AO Queue */
QEvt const * l_InOutQSto[64];

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${components::InputOutput::AO_InOut} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::InputOutput::AO_InOut} .....................................*/
QActive * const AO_InOut =&l_InOut.super;
/*$enddef${components::InputOutput::AO_InOut} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${components::InputOutput::InOut_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::InputOutput::InOut_ctor} ...................................*/
void InOut_ctor(void) {
    static uint8_t bInitDone = (uint8_t)0;
    gpio_config_t io_conf;
    uint32_t idx;
    uint64_t input_bit_mask;
    char taskName[16];
    InOut *me;

    if(bInitDone == (uint8_t)0) {
        me = &l_InOut;
        /* Call constructor */
        QActive_ctor(&me->super, Q_STATE_CAST(&InOut_initial));
        /* Call orthogonal Component constructor */

        /* Call Timer Constructor */
        QTimeEvt_ctorX(&me->tickTimeEvt,  &me->super, TICK_SIG,  0U);

        /* Initialize members */

        /* Initialize IO */
        io_conf.intr_type = GPIO_PIN_INTR_DISABLE;
        io_conf.mode = GPIO_MODE_INPUT;
        input_bit_mask = 0;
        for(idx = 0; idx < N_INPUT_ID; idx++) {
            input_bit_mask |= (1ULL << INPUT_IO[idx]);
        }
        io_conf.pin_bit_mask = input_bit_mask;
        io_conf.pull_down_en = 0;
        io_conf.pull_up_en = 1;
        gpio_config(&io_conf);

        /* Initialize input state */
        for(idx = 0; idx < N_INPUT_ID; idx++) {
            if(gpio_get_level(INPUT_IO[idx])) {
                me->inputState[idx] = 1;
                me->debouncer[idx] = UINT32_MAX;
            } else {
                me->inputState[idx] = 0;
                me->debouncer[idx] = 0;
            }
        }

        /* Start active object */
        sprintf(taskName, "AO_IN_OUT");
        QActive_setAttr(AO_InOut, TASK_NAME_ATTR, taskName);
        QACTIVE_START(
            AO_InOut,
            PRIORITY_IN_OUT,
            l_InOutQSto,
            Q_DIM(l_InOutQSto),
            inOutStack,
            sizeof(inOutStack),
            (QEvt *)0);

        bInitDone = (uint8_t)1;
    }
}
/*$enddef${components::InputOutput::InOut_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${components::InputOutput::InOut_GetInputState} vvvvvvvvvvvvvvvvvvv*/
/*${components::InputOutput::InOut_GetInputState} ..........................*/
bool InOut_GetInputState(INPUT_ID_T id) {
    InOut * me = &l_InOut;
    bool retval = false;

    if(id < N_INPUT_ID) {
        retval = me->inputState[id];
    }

    return(retval);
}
/*$enddef${components::InputOutput::InOut_GetInputState} ^^^^^^^^^^^^^^^^^^^*/

/*$define${components::InputOutput::InOut} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::InputOutput::InOut} ........................................*/
/*${components::InputOutput::InOut::SM} ....................................*/
static QState InOut_initial(InOut * const me, QEvt const * const e) {
    /*${components::InputOutput::InOut::SM::initial} */
    return Q_TRAN(&InOut_TOP);
}
/*${components::InputOutput::InOut::SM::TOP} ...............................*/
static QState InOut_TOP(InOut * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::InputOutput::InOut::SM::TOP} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->tickTimeEvt, INOUT_TICK_INTERVAL_MS, INOUT_TICK_INTERVAL_MS);
            status_ = Q_HANDLED();
            break;
        }
        /*${components::InputOutput::InOut::SM::TOP::TICK} */
        case TICK_SIG: {
            uint32_t idx;
            InputEvt * pEvt;

            for(idx = 0; idx < N_INPUT_ID; idx++) {
                me->debouncer[idx] = ((me->debouncer[idx]) << 1) + gpio_get_level(INPUT_IO[idx]);
                if((me->debouncer[idx] & IO_DEBOUNCE_MASK(INPUT_DEBOUNCE_THRES[idx])) ==
                    IO_DEBOUNCE_MASK(INPUT_DEBOUNCE_THRES[idx])) {
                    if(me->inputState[idx] != 1) {
                        pEvt = Q_NEW(InputEvt, INPUT_POSITIVE_EDGE_SIG);
                        me->inputState[idx] = 1;
                        pEvt->id = idx;
                        QF_PUBLISH((QEvt *)pEvt, me);
                    }
                } else if((me->debouncer[idx] & IO_DEBOUNCE_MASK(INPUT_DEBOUNCE_THRES[idx])) == 0) {
                    if(me->inputState[idx] != 0) {
                        pEvt = Q_NEW(InputEvt, INPUT_NEGATIVE_EDGE_SIG);
                        me->inputState[idx] = 0;
                        pEvt->id = idx;
                        QF_PUBLISH((QEvt *)pEvt, me);
                    }
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${components::InputOutput::InOut} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
