/*$file${components::SystemManagement::.::SysMngt.c} vvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: kahayag_suga.qm
* File:  ${components::SystemManagement::.::SysMngt.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${components::SystemManagement::.::SysMngt.c} ^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "signalList.h"
#include "priorityList.h"
#include "SysMngt.h"
#include "Wifi.h"
#include "Provision.h"
#include "InOut.h"

#include "tcpip_adapter.h"
#include "esp_event_loop.h"
#include "esp_log.h"
#include "esp_wifi.h"

Q_DEFINE_THIS_FILE

#define SYS_MNGT_DEBUG  (1)
#if(SYS_MNGT_DEBUG == 1)
#define DEBUG_SYS_MNGT(x)    printf(x)
#else
#define DEBUG_SYS_MNGT(x)
#endif /* #if(SYS_MNGT_DEBUG == 1) */

/*$declare${components::SystemManagement::SysMngt} vvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::SystemManagement::SysMngt} .................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QHsm * pWifi;
    QHsm * pProvision;
    QTimeEvt tickTimeEvt;
    INPUT_ID_T userBtnId;
    bool isCredentialValid;
    int provision_security;
} SysMngt;

/* private: */
static esp_err_t SysMngt_event_handler(void * ctx, system_event_t * event);
static esp_err_t SysMngt_prov_event_handler(void * ctx, system_event_t * event);

/* protected: */
static QState SysMngt_initial(SysMngt * const me, QEvt const * const e);
static QState SysMngt_TOP(SysMngt * const me, QEvt const * const e);
static QState SysMngt_BOOT_CHECK(SysMngt * const me, QEvt const * const e);
static QState SysMngt_BOOT_BTN_CHECK(SysMngt * const me, QEvt const * const e);
static QState SysMngt_BOOT_CRED_CHECK(SysMngt * const me, QEvt const * const e);
static QState SysMngt_PROVISION(SysMngt * const me, QEvt const * const e);
static QState SysMngt_NORMAL(SysMngt * const me, QEvt const * const e);
/*$enddecl${components::SystemManagement::SysMngt} ^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Local Object */
static SysMngt l_SysMngt;
/* FreeRTOS stack for AO */
static StackType_t sysMngtStack[2*configIDLE_TASK_STACK_SIZE];
/* AO Queue */
QEvt const * l_SysMngtQSto[64];

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${components::SystemManagement::TAG} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::SystemManagement::TAG} .....................................*/
static const char * TAG ="AppMngt";
/*$enddef${components::SystemManagement::TAG} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${components::SystemManagement::AO_SysMngt} vvvvvvvvvvvvvvvvvvvvvvv*/

/** Opaque pointer to SysMngt AO */
/*${components::SystemManagement::AO_SysMngt} ..............................*/
QActive * const AO_SysMngt = &l_SysMngt.super;
/*$enddef${components::SystemManagement::AO_SysMngt} ^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${components::SystemManagement::SysMgnt_ctor} vvvvvvvvvvvvvvvvvvvvv*/
/*${components::SystemManagement::SysMgnt_ctor} ............................*/
void SysMgnt_ctor(void) {
    static uint8_t bInitDone = (uint8_t)0;
    char taskName[16];
    SysMngt *me;

    if(bInitDone == (uint8_t)0) {
        me = &l_SysMngt;
        /* Call constructor */
        QActive_ctor(&me->super, Q_STATE_CAST(&SysMngt_initial));
        /* Call orthogonal Component constructor */
        me->pWifi = Wifi_ctor(&(me->super.super));
        me->pProvision = Prov_ctor(&(me->super.super));
        /* Call Timer Constructor */
        QTimeEvt_ctorX(&me->tickTimeEvt,  &me->super, TICK_SIG,  0U);

        /* Initialize members */
        me->userBtnId = SYS_MNGT_USER_BTN_ID;

        /* Start active object */
        sprintf(taskName, "AO_SYS_MNGT");
        QActive_setAttr(AO_SysMngt, TASK_NAME_ATTR, taskName);
        QACTIVE_START(
            AO_SysMngt,
            PRIORITY_SYS_MNGT,
            l_SysMngtQSto,
            Q_DIM(l_SysMngtQSto),
            sysMngtStack,
            sizeof(sysMngtStack),
            (QEvt *)0);

        bInitDone = (uint8_t)1;
    }
}
/*$enddef${components::SystemManagement::SysMgnt_ctor} ^^^^^^^^^^^^^^^^^^^^^*/

/*$define${components::SystemManagement::SysMngt} vvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::SystemManagement::SysMngt} .................................*/
/*${components::SystemManagement::SysMngt::event_handler} ..................*/
static esp_err_t SysMngt_event_handler(void * ctx, system_event_t * event) {
    /* Invoke Provisioning event handler first */
    SysMngt_prov_event_handler(ctx, event);

    switch(event->event_id) {
    case SYSTEM_EVENT_AP_START:
        ESP_LOGI(TAG, "SoftAP started");
        break;
    case SYSTEM_EVENT_AP_STOP:
        ESP_LOGI(TAG, "SoftAP stopped");
        break;
    case SYSTEM_EVENT_STA_START:
        esp_wifi_connect();
        break;
    case SYSTEM_EVENT_STA_GOT_IP:
        ESP_LOGI(TAG, "got ip:%s",
                 ip4addr_ntoa(&event->event_info.got_ip.ip_info.ip));
        break;
    case SYSTEM_EVENT_AP_STACONNECTED:
        ESP_LOGI(TAG, "station:"MACSTR" join, AID=%d",
                 MAC2STR(event->event_info.sta_connected.mac),
                 event->event_info.sta_connected.aid);
        break;
    case SYSTEM_EVENT_AP_STADISCONNECTED:
        ESP_LOGI(TAG, "station:"MACSTR"leave, AID=%d",
                 MAC2STR(event->event_info.sta_disconnected.mac),
                 event->event_info.sta_disconnected.aid);
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        break;
    default:
        break;
    }
    return ESP_OK;
}

/*${components::SystemManagement::SysMngt::prov_event_handler} .............*/
static esp_err_t SysMngt_prov_event_handler(void * ctx, system_event_t * event) {
    return ESP_OK;
}

/*${components::SystemManagement::SysMngt::SM} .............................*/
static QState SysMngt_initial(SysMngt * const me, QEvt const * const e) {
    /*${components::SystemManagement::SysMngt::SM::initial} */
    QS_OBJ_DICTIONARY(&l_SysMngt);

    /* Initial Transition of orthogonal component */
    QHSM_INIT(me->pWifi, (QEvt*)0);
    QHSM_INIT(me->pProvision, (QEvt*)0);

    QS_FUN_DICTIONARY(&SysMngt_TOP);
    QS_FUN_DICTIONARY(&SysMngt_BOOT_CHECK);
    QS_FUN_DICTIONARY(&SysMngt_BOOT_BTN_CHECK);
    QS_FUN_DICTIONARY(&SysMngt_BOOT_CRED_CHECK);
    QS_FUN_DICTIONARY(&SysMngt_PROVISION);
    QS_FUN_DICTIONARY(&SysMngt_NORMAL);

    return Q_TRAN(&SysMngt_TOP);
}
/*${components::SystemManagement::SysMngt::SM::TOP} ........................*/
static QState SysMngt_TOP(SysMngt * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::SysMngt::SM::TOP} */
        case Q_ENTRY_SIG: {
            QActive_subscribe((QActive *)me, INPUT_POSITIVE_EDGE_SIG);
            QActive_subscribe((QActive *)me, INPUT_NEGATIVE_EDGE_SIG);

            QTimeEvt_armX(&me->tickTimeEvt, SYS_MNGT_TICK_INTERVAL_MS, SYS_MNGT_TICK_INTERVAL_MS);
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP} */
        case Q_EXIT_SIG: {
            QActive_unsubscribe((QActive *)me, INPUT_POSITIVE_EDGE_SIG);
            QActive_unsubscribe((QActive *)me, INPUT_NEGATIVE_EDGE_SIG);

            QTimeEvt_disarm(&me->tickTimeEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&SysMngt_BOOT_CHECK);
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::TICK, INPUT_POSITIVE_EDGE, INPUT~} */
        case TICK_SIG: /* intentionally fall through */
        case INPUT_POSITIVE_EDGE_SIG: /* intentionally fall through */
        case INPUT_NEGATIVE_EDGE_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK} ............*/
static QState SysMngt_BOOT_CHECK(SysMngt * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "BOOT_CHECK: entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "BOOT_CHECK: exit");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::TICK} */
        case TICK_SIG: {
            /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::TICK::[userBtnPressed]} */
            if (false == InOut_GetInputState(me->userBtnId)) {
                status_ = Q_TRAN(&SysMngt_BOOT_BTN_CHECK);
            }
            /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::TICK::[else]} */
            else {
                status_ = Q_TRAN(&SysMngt_BOOT_CRED_CHECK);
            }
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::INPUT_POSITIVE_EDGE, INPUT_NEGAT~} */
        case INPUT_POSITIVE_EDGE_SIG: /* intentionally fall through */
        case INPUT_NEGATIVE_EDGE_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMngt_TOP);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_BTN_CHECK} */
static QState SysMngt_BOOT_BTN_CHECK(SysMngt * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_BTN_CHECK} */
        case Q_ENTRY_SIG: {
            QTimeEvt_disarm(&me->tickTimeEvt);
            QTimeEvt_armX(&me->tickTimeEvt, SYS_MNGT_PROV_BTN_TICK_INT, SYS_MNGT_PROV_BTN_TICK_INT);

            ESP_LOGI(TAG, "BOOT_BTN_CHECK: entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_BTN_CHECK} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->tickTimeEvt);
            QTimeEvt_armX(&me->tickTimeEvt, SYS_MNGT_TICK_INTERVAL_MS, SYS_MNGT_TICK_INTERVAL_MS);

            ESP_LOGI(TAG, "BOOT_BTN_CHECK: exit");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_BTN_CHECK::TICK} */
        case TICK_SIG: {
            status_ = Q_TRAN(&SysMngt_PROVISION);
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_BTN_CHECK::INPUT_POSITIVE_EDGE} */
        case INPUT_POSITIVE_EDGE_SIG: {
            status_ = Q_TRAN(&SysMngt_BOOT_CRED_CHECK);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMngt_BOOT_CHECK);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_CRED_CHECK} */
static QState SysMngt_BOOT_CRED_CHECK(SysMngt * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_CRED_CHECK} */
        case Q_ENTRY_SIG: {
            /* Check Credential */
            /// TODO

            // mock
            me->isCredentialValid = true;

            ESP_LOGI(TAG, "BOOT_CRED_CHECK: entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_CRED_CHECK} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "BOOT_CRED_CHECK: exit");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_CRED_CHECK::TICK} */
        case TICK_SIG: {
            /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_CRED_CHECK::TICK::[InvalidCredential]} */
            if (!(me->isCredentialValid)) {
                status_ = Q_TRAN(&SysMngt_PROVISION);
            }
            /*${components::SystemManagement::SysMngt::SM::TOP::BOOT_CHECK::BOOT_CRED_CHECK::TICK::[else]} */
            else {
                status_ = Q_TRAN(&SysMngt_NORMAL);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMngt_BOOT_CHECK);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::SysMngt::SM::TOP::PROVISION} .............*/
static QState SysMngt_PROVISION(SysMngt * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::SysMngt::SM::TOP::PROVISION} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "PROVISION: entry");

            QEvt *pEvt = Q_NEW(QEvt, START_PROVISION_SIG);
            QHSM_DISPATCH(me->pProvision, pEvt);
            QF_gc((QEvt *)pEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::PROVISION} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "PROVISION: exit");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMngt_TOP);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::SysMngt::SM::TOP::NORMAL} ................*/
static QState SysMngt_NORMAL(SysMngt * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::SysMngt::SM::TOP::NORMAL} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "NORMAL: entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::SysMngt::SM::TOP::NORMAL} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "NORMAL: exit");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMngt_TOP);
            break;
        }
    }
    return status_;
}
/*$enddef${components::SystemManagement::SysMngt} ^^^^^^^^^^^^^^^^^^^^^^^^^^*/
