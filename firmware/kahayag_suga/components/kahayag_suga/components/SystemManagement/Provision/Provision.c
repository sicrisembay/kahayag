/*$file${components::SystemManagement::components::provision::.::Provision.c} */
/*
* Model: kahayag_suga.qm
* File:  ${components::SystemManagement::components::provision::.::Provision.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${components::SystemManagement::components::provision::.::Provision.c} */
#include "qpc.h"
#include "signalList.h"
#include "Provision.h"
#include "Wifi.h"
#include "worker.h"

#include "esp_log.h"
#include "esp_wifi.h"
#include "protocomm.h"
#include "protocomm_httpd.h"
#include "protocomm_security0.h"
#include "protocomm_security1.h"
#include "wifi_provisioning/wifi_config.h"

#include "string.h"

/*$declare${components::SystemManagement::components::provision::Provision} */
/*${components::SystemManagement::components::provision::Provision} ........*/
typedef struct {
/* protected: */
    QHsm super;

/* private: */
    QTimeEvt timeoutEvt;
    QActive * pParent;
    protocomm_t * pc;
    int security;
    const protocomm_security_pop_t * pop;
    wifi_prov_sta_state_t wifi_state;
    wifi_prov_sta_fail_reason_t wifi_disconnect_reason;
    char ssid[MAX_PROV_SSID_LEN + 1];
    char password[MAX_PROV_PASS_LEN+1];
    wifi_config_t * wifi_cfg;
} Provision;

/* protected: */
static QState Provision_initial(Provision * const me, QEvt const * const e);
static QState Provision_TOP(Provision * const me, QEvt const * const e);
static QState Provision_INACTIVE(Provision * const me, QEvt const * const e);
static QState Provision_ACTIVE(Provision * const me, QEvt const * const e);
static QState Provision_SERVICE_ACTIVE(Provision * const me, QEvt const * const e);
/*$enddecl${components::SystemManagement::components::provision::Provision} */


Provision l_Provision;
/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${components::SystemManagement::components::provision::TAG} vvvvvvv*/
/*${components::SystemManagement::components::provision::TAG} ..............*/
static const char * TAG ="PROV_QHSM";
/*$enddef${components::SystemManagement::components::provision::TAG} ^^^^^^^*/

/*$declare${components::SystemManagement::components::provision::Prov_get_status_handler} */
/*${components::SystemManagement::components::provision::Prov_get_status_handler} */
static esp_err_t Prov_get_status_handler(wifi_prov_config_get_data_t * resp_data);
/*$enddecl${components::SystemManagement::components::provision::Prov_get_status_handler} */
/*$declare${components::SystemManagement::components::provision::Prov_set_config_handler} */
/*${components::SystemManagement::components::provision::Prov_set_config_handler} */
static esp_err_t Prov_set_config_handler(const wifi_prov_config_set_data_t * req_data);
/*$enddecl${components::SystemManagement::components::provision::Prov_set_config_handler} */
/*$declare${components::SystemManagement::components::provision::Prov_get_wifi_state} */
/*${components::SystemManagement::components::provision::Prov_get_wifi_state} */
static esp_err_t Prov_get_wifi_state(wifi_prov_sta_state_t * state);
/*$enddecl${components::SystemManagement::components::provision::Prov_get_wifi_state} */
/*$declare${components::SystemManagement::components::provision::Prov_get_wifi_disconnect_reason} */
/*${components::SystemManagement::components::provision::Prov_get_wifi_disconnect_reason} */
static esp_err_t Prov_get_wifi_disconnect_reason(wifi_prov_sta_fail_reason_t * reason);
/*$enddecl${components::SystemManagement::components::provision::Prov_get_wifi_disconnect_reason} */
/*$declare${components::SystemManagement::components::provision::Prov_apply_config_handler} */
/*${components::SystemManagement::components::provision::Prov_apply_config_handler} */
static esp_err_t Prov_apply_config_handler(void);
/*$enddecl${components::SystemManagement::components::provision::Prov_apply_config_handler} */
/*$declare${components::SystemManagement::components::provision::Prov_configure_sta} */
/*${components::SystemManagement::components::provision::Prov_configure_sta} */
static esp_err_t Prov_configure_sta(wifi_config_t * wifi_cfg);
/*$enddecl${components::SystemManagement::components::provision::Prov_configure_sta} */

/*$define${components::SystemManagement::components::provision::Prov_get_status_handler} */
/*${components::SystemManagement::components::provision::Prov_get_status_handler} */
static esp_err_t Prov_get_status_handler(wifi_prov_config_get_data_t * resp_data) {
    Provision * me = &l_Provision;
    /* Initialise to zero */
    memset(resp_data, 0, sizeof(wifi_prov_config_get_data_t));

    if (Prov_get_wifi_state(&resp_data->wifi_state) != ESP_OK) {
        ESP_LOGW(TAG, "Prov app not running");
        return ESP_FAIL;
    }

    if (me->wifi_state == WIFI_PROV_STA_CONNECTED) {
        ESP_LOGI(TAG, "Connected state");

        /* IP Addr assigned to STA */
        tcpip_adapter_ip_info_t ip_info;
        tcpip_adapter_get_ip_info(TCPIP_ADAPTER_IF_STA, &ip_info);
        char *ip_addr = ip4addr_ntoa(&ip_info.ip);
        strcpy(resp_data->conn_info.ip_addr, ip_addr);

        /* AP information to which STA is connected */
        wifi_ap_record_t ap_info;
        esp_wifi_sta_get_ap_info(&ap_info);
        memcpy(resp_data->conn_info.bssid, (char *)ap_info.bssid, sizeof(ap_info.bssid));
        memcpy(resp_data->conn_info.ssid,  (char *)ap_info.ssid,  sizeof(ap_info.ssid));
        resp_data->conn_info.channel   = ap_info.primary;
        resp_data->conn_info.auth_mode = ap_info.authmode;
    } else if (me->wifi_state == WIFI_PROV_STA_DISCONNECTED) {
        ESP_LOGI(TAG, "Disconnected state");

        /* If disconnected, convey reason */
        Prov_get_wifi_disconnect_reason(&resp_data->fail_reason);
    } else {
        ESP_LOGI(TAG, "Connecting state");
    }
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_get_status_handler} */
/*$define${components::SystemManagement::components::provision::Prov_set_config_handler} */
/*${components::SystemManagement::components::provision::Prov_set_config_handler} */
static esp_err_t Prov_set_config_handler(const wifi_prov_config_set_data_t * req_data) {
    Provision * me = &l_Provision;

    if (me->wifi_cfg) {
        free(me->wifi_cfg);
        me->wifi_cfg = NULL;
    }

    me->wifi_cfg = (wifi_config_t *) calloc(1, sizeof(wifi_config_t));
    if (!(me->wifi_cfg)) {
        ESP_LOGE(TAG, "Unable to alloc wifi config");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "WiFi Credentials Received : \n\tssid %s \n\tpassword %s",
             req_data->ssid, req_data->password);
    memcpy((char *) me->wifi_cfg->sta.ssid, req_data->ssid,
           strnlen(req_data->ssid, sizeof(me->wifi_cfg->sta.ssid)));
    memcpy((char *) me->wifi_cfg->sta.password, req_data->password,
           strnlen(req_data->password, sizeof(me->wifi_cfg->sta.password)));
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_set_config_handler} */
/*$define${components::SystemManagement::components::provision::Prov_get_wifi_state} */
/*${components::SystemManagement::components::provision::Prov_get_wifi_state} */
static esp_err_t Prov_get_wifi_state(wifi_prov_sta_state_t * state) {
    Provision *me = &l_Provision;

    if (state == NULL) {
        return ESP_FAIL;
    }

    *state = me->wifi_state;
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_get_wifi_state} */
/*$define${components::SystemManagement::components::provision::wifi_prov_handlers} */
/*${components::SystemManagement::components::provision::wifi_prov_handlers} */
static wifi_prov_config_handlers_t wifi_prov_handlers = {
    .get_status_handler   = Prov_get_status_handler,
    .set_config_handler   = Prov_set_config_handler,
    .apply_config_handler = Prov_apply_config_handler,
};
/*$enddef${components::SystemManagement::components::provision::wifi_prov_handlers} */
/*$define${components::SystemManagement::components::provision::Prov_get_wifi_disconnect_reason} */
/*${components::SystemManagement::components::provision::Prov_get_wifi_disconnect_reason} */
static esp_err_t Prov_get_wifi_disconnect_reason(wifi_prov_sta_fail_reason_t * reason) {
    Provision * me = &l_Provision;

    if (reason == NULL) {
        return ESP_FAIL;
    }

    if (me->wifi_state != WIFI_PROV_STA_DISCONNECTED) {
        return ESP_FAIL;
    }

    *reason = me->wifi_disconnect_reason;
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_get_wifi_disconnect_reason} */
/*$define${components::SystemManagement::components::provision::Prov_apply_config_handler} */
/*${components::SystemManagement::components::provision::Prov_apply_config_handler} */
static esp_err_t Prov_apply_config_handler(void) {
    Provision * me = &l_Provision;

    if (!(me->wifi_cfg)) {
        ESP_LOGE(TAG, "WiFi config not set");
        return ESP_FAIL;
    }

    Prov_configure_sta(me->wifi_cfg);
    ESP_LOGI(TAG, "WiFi Credentials Applied");

    free(me->wifi_cfg);
    me->wifi_cfg = NULL;
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_apply_config_handler} */
/*$define${components::SystemManagement::components::provision::Prov_configure_sta} */
/*${components::SystemManagement::components::provision::Prov_configure_sta} */
static esp_err_t Prov_configure_sta(wifi_config_t * wifi_cfg) {
    Provision * me = &l_Provision;

    /* Configure WiFi as both AP and Station */
    if (esp_wifi_set_mode(WIFI_MODE_APSTA) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi mode");
        return ESP_FAIL;
    }
    /* Configure WiFi station with host credentials
     * provided during provisioning */
    if (esp_wifi_set_config(ESP_IF_WIFI_STA, me->wifi_cfg) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi configuration");
        return ESP_FAIL;
    }
    /* Restart WiFi */
    if (esp_wifi_start() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to restart WiFi");
        return ESP_FAIL;
    }
    /* Connect to AP */
    if (esp_wifi_connect() != ESP_OK) {
        ESP_LOGE(TAG, "Failed to connect WiFi");
        return ESP_FAIL;
    }

    if (me) {
        /* Reset wifi station state for provisioning app */
        me->wifi_state = WIFI_PROV_STA_CONNECTING;
    }
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_configure_sta} */


/*$define${components::SystemManagement::components::provision::Prov_ctor} v*/
/*${components::SystemManagement::components::provision::Prov_ctor} ........*/
QHsm * Prov_ctor(QActive * const parent) {
    static uint8_t bInitDone = (uint8_t)0;
    Provision *me;

    if(bInitDone == (uint8_t)0) {
        me = &l_Provision;
        /* Call constructor */
        QHsm_ctor(&me->super, Q_STATE_CAST(&Provision_initial));

        /* Call orthogonal Component constructor */

        /* Call Timer Constructor */
        QTimeEvt_ctorX(&me->timeoutEvt, parent, PROV_SERVICE_TIMEOUT_SIG, 0U);

        /* Initialize members */
        me->pParent = parent;
        me->pc = NULL;
        me->security = 0;
        me->pop = NULL;
        memset(me->ssid, 0, sizeof(me->ssid));
        snprintf(me->ssid, MAX_PROV_SSID_LEN, "SUGA_XXXXXX");
        memset(me->password, 0, sizeof(me->password));
        snprintf(me->password, MAX_PROV_PASS_LEN, "password123");

        bInitDone = (uint8_t)1;
    }

    return(&me->super);
}
/*$enddef${components::SystemManagement::components::provision::Prov_ctor} ^*/
/*$define${components::SystemManagement::components::provision::Prov_EventHandler} */
/*${components::SystemManagement::components::provision::Prov_EventHandler} */
static esp_err_t Prov_EventHandler(void * ctx, system_event_t * event) {
    Provision * me = &l_Provision;

    /* For accessing reason codes in case of disconnection */
    system_event_info_t *info = &event->event_info;

    /* If pointer to provisioning application data is NULL
     * then provisioning is not running, therefore return without
     * error */
    if (!me) {
        return ESP_OK;
    }

    switch(event->event_id) {
    case SYSTEM_EVENT_STA_START:
        ESP_LOGI(TAG, "STA Start");
        /* Once configuration is received by protocomm server,
         * device is restarted as both AP and Station.
         * Once station starts, wait for connection to
         * establish with configured host SSID and password */
        me->wifi_state = WIFI_PROV_STA_CONNECTING;
        break;

    case SYSTEM_EVENT_STA_GOT_IP:
        ESP_LOGI(TAG, "STA Got IP");
        /* Station got IP. That means configuraion is successful.
         * Schedule timer to stop provisioning app after 30 seconds. */
        me->wifi_state = WIFI_PROV_STA_CONNECTED;
        /* Note that, after restarting the WiFi in Station + AP mode, the
         * user gets disconnected from the AP for a while. But at the same
         * time, the user app requests for status update from the device
         * to verify that the provisioning was successful. Therefore, the
         * turning off of the AP must be delayed long enough for the user
         * to reconnect and get STA connection status from the device.
         * Otherwise, the AP will be turned off before the user can
         * reconnect and thus the user app will see connection timed out,
         * signalling a failure in provisioning. */
        QTimeEvt_rearm(&me->timeoutEvt, PROVISION_TIMEOUT);
        break;

    case SYSTEM_EVENT_STA_DISCONNECTED:
        ESP_LOGE(TAG, "STA Disconnected");
        /* Station couldn't connect to configured host SSID */
        me->wifi_state = WIFI_PROV_STA_DISCONNECTED;
        ESP_LOGE(TAG, "Disconnect reason : %d", info->disconnected.reason);

        /* Set code corresponding to the reason for disconnection */
        switch (info->disconnected.reason) {
        case WIFI_REASON_AUTH_EXPIRE:
        case WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT:
        case WIFI_REASON_BEACON_TIMEOUT:
        case WIFI_REASON_AUTH_FAIL:
        case WIFI_REASON_ASSOC_FAIL:
        case WIFI_REASON_HANDSHAKE_TIMEOUT:
            ESP_LOGI(TAG, "STA Auth Error");
            me->wifi_disconnect_reason = WIFI_PROV_STA_AUTH_ERROR;
            break;
        case WIFI_REASON_NO_AP_FOUND:
            ESP_LOGI(TAG, "STA AP Not found");
            me->wifi_disconnect_reason = WIFI_PROV_STA_AP_NOT_FOUND;
            break;
        default:
            /* If none of the expected reasons,
             * retry connecting to host SSID */
            me->wifi_state = WIFI_PROV_STA_CONNECTING;
            esp_wifi_connect();
            break;
        }
        break;

    default:
        break;
    }
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_EventHandler} */

/*$define${components::SystemManagement::components::provision::Prov_start_wifi_ap} */
/*${components::SystemManagement::components::provision::Prov_start_wifi_ap} */
static void Prov_start_wifi_ap(void) {
    uint8_t eth_mac[6];
    esp_err_t err = ESP_OK;
    Provision *me = &l_Provision;
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    QEvt *pEvt = NULL;

    /* Initialise WiFi with default configuration */
    err = esp_wifi_init(&cfg);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to init WiFi : %d", err);
        pEvt = Q_NEW(QEvt, AP_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }

    /* Set Wifi mode to AP */
    ESP_LOGI(TAG, "Set WiFi mode to AP");
    err = esp_wifi_set_mode(WIFI_MODE_AP);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi mode : %d", err);
        pEvt = Q_NEW(QEvt, AP_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }

    /* SSID is based on MAC */
    err = esp_wifi_get_mac(WIFI_IF_STA, eth_mac);
    if(err != ESP_OK) {
        ESP_LOGE(TAG, "Error in getting mac: %d", err);
    } else {
        snprintf(me->ssid, MAX_PROV_SSID_LEN, "SUGA_%02X%02X%02X",
                eth_mac[3], eth_mac[4], eth_mac[5]);
    }

    /* Build WiFi configuration for AP mode */
    wifi_config_t wifi_config = {
        .ap = {
            .max_connection = 5,
        },
    };

    strncpy((char *) wifi_config.ap.ssid, me->ssid, sizeof(wifi_config.ap.ssid));
    wifi_config.ap.ssid_len = strlen(me->ssid);

    if (strlen(me->password) == 0) {
        memset(wifi_config.ap.password, 0, sizeof(wifi_config.ap.password));
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    } else {
        strncpy((char *) wifi_config.ap.password, me->password, sizeof(wifi_config.ap.password));
        wifi_config.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
    }

    /* Start WiFi in AP mode with configuration built above */
    ESP_LOGI(TAG, "Configure WiFi AP");
    err = esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi config : %d", err);
        pEvt = Q_NEW(QEvt, AP_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }
    ESP_LOGI(TAG, "Start WiFi");
    err = esp_wifi_start();
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start WiFi : %d", err);
        pEvt = Q_NEW(QEvt, AP_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }

    pEvt = Q_NEW(QEvt, AP_STARTED_SIG);
    QACTIVE_POST(me->pParent, pEvt, me);

}
/*$enddef${components::SystemManagement::components::provision::Prov_start_wifi_ap} */
/*$define${components::SystemManagement::components::provision::Prov_start_service} */
/*${components::SystemManagement::components::provision::Prov_start_service} */
static void Prov_start_service(void) {
    Provision * me = &l_Provision;
    QEvt * pEvt = NULL;

    /* Create new protocomm instance */
    me->pc = protocomm_new();
    if (me->pc == NULL) {
        ESP_LOGE(TAG, "Failed to create new protocomm instance");
        pEvt = Q_NEW(QEvt, PROV_SERVICE_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }

    /* Config for protocomm_httpd_start() */
    protocomm_httpd_config_t pc_config = PROTOCOMM_HTTPD_DEFAULT_CONFIG();

    /* Start protocomm server on top of HTTP */
    if (protocomm_httpd_start(me->pc, &pc_config) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start protocomm HTTP server");
        pEvt = Q_NEW(QEvt, PROV_SERVICE_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }

    /* Set protocomm version verification endpoint for protocol */
    protocomm_set_version(me->pc, "proto-ver", "V0.1");

    /* Set protocomm security type for endpoint */
    if (me->security == 0) {
        protocomm_set_security(me->pc, "prov-session", &protocomm_security0, NULL);
    } else if (me->security == 1) {
        protocomm_set_security(me->pc, "prov-session", &protocomm_security1, me->pop);
    }

    /* Add endpoint for provisioning to set wifi station config */
    if (protocomm_add_endpoint(me->pc, "prov-config",
                               wifi_prov_config_data_handler,
                               (void *) &wifi_prov_handlers) != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set provisioning endpoint");
        protocomm_httpd_stop(me->pc);
        pEvt = Q_NEW(QEvt, PROV_SERVICE_START_FAILED_SIG);
        QACTIVE_POST(me->pParent, pEvt, me);
        return;
    }

    pEvt = Q_NEW(QEvt, PROV_SERVICE_STARTED_SIG);
    QACTIVE_POST(me->pParent, pEvt, me);

}
/*$enddef${components::SystemManagement::components::provision::Prov_start_service} */
/*$define${components::SystemManagement::components::provision::Prov_stop_service} */
/*${components::SystemManagement::components::provision::Prov_stop_service} */
static void Prov_stop_service(void) {
    Provision * me = &l_Provision;
    QEvt * pEvt = NULL;

    /* Remove provisioning endpoint */
    protocomm_remove_endpoint(me->pc, "prov-config");
    /* Unset provisioning security */
    protocomm_unset_security(me->pc, "prov-session");
    /* Unset provisioning version endpoint */
    protocomm_unset_version(me->pc, "proto-ver");
    /* Stop protocomm server */
    protocomm_httpd_stop(me->pc);
    /* Delete protocomm instance */
    protocomm_delete(me->pc);

    pEvt = Q_NEW(QEvt, PROV_SERVICE_STOPPED_SIG);
    QACTIVE_POST(me->pParent, pEvt, me);
}
/*$enddef${components::SystemManagement::components::provision::Prov_stop_service} */

/*$define${components::SystemManagement::components::provision::Provision} v*/
/*${components::SystemManagement::components::provision::Provision} ........*/
/*${components::SystemManagement::components::provision::Provision::SM} ....*/
static QState Provision_initial(Provision * const me, QEvt const * const e) {
    /*${components::SystemManagement::components::provision::Provision::SM::initial} */

    QS_FUN_DICTIONARY(&Provision_TOP);
    QS_FUN_DICTIONARY(&Provision_INACTIVE);
    QS_FUN_DICTIONARY(&Provision_ACTIVE);
    QS_FUN_DICTIONARY(&Provision_SERVICE_ACTIVE);

    return Q_TRAN(&Provision_TOP);
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP} */
static QState Provision_TOP(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Provision_INACTIVE);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE} */
static QState Provision_INACTIVE(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "INACTIVE entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "INACTIVE exit");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE::START_PROVISION} */
        case START_PROVISION_SIG: {
            status_ = Q_TRAN(&Provision_ACTIVE);
            break;
        }
        default: {
            status_ = Q_SUPER(&Provision_TOP);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE} */
static QState Provision_ACTIVE(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE} */
        case Q_ENTRY_SIG: {
            esp_err_t retval = ESP_OK;
            QEvt *pEvt = NULL;

            ESP_LOGI(TAG, "ACTIVE: entry");

            ESP_LOGI(TAG, "Starting WiFi SoftAP provisioning");
            ESP_ERROR_CHECK(Wifi_AddHook(Prov_EventHandler));

            /* Start Wifi AP */
            retval = doWork(Prov_start_wifi_ap);
            if(retval != ESP_OK) {
                ESP_LOGE(TAG, "Failed to create worker thread for Prov_start_wifi_ap");
                pEvt = Q_NEW(QEvt, AP_START_FAILED_SIG);
                QACTIVE_POST(me->pParent, pEvt, me);
            }

            /* Arm Timeout Timer, One-shot */
            QTimeEvt_armX(&me->timeoutEvt, PROVISION_TIMEOUT, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "ACTIVE exit");

            ESP_ERROR_CHECK(Wifi_RemoveHook(Prov_EventHandler));

            /* Disarm Timeout Timer */
            QTimeEvt_disarm(&me->timeoutEvt);
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::AP_STARTED} */
        case AP_STARTED_SIG: {
            ESP_LOGI(TAG, "Wifi AP Started");
            status_ = Q_TRAN(&Provision_SERVICE_ACTIVE);
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::AP_START_FAILED} */
        case AP_START_FAILED_SIG: {
            ESP_LOGI(TAG, "Wifi AP Start Failed");
            status_ = Q_TRAN(&Provision_INACTIVE);
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::PROV_SERVICE_TIMEOUT} */
        case PROV_SERVICE_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Provision_INACTIVE);
            break;
        }
        default: {
            status_ = Q_SUPER(&Provision_TOP);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE} */
static QState Provision_SERVICE_ACTIVE(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE} */
        case Q_ENTRY_SIG: {
            esp_err_t retval = ESP_OK;
            QEvt *pEvt = NULL;

            ESP_LOGI(TAG, "SERVICE_ACTIVE: Entry");
            ESP_LOGI(TAG, "Start provisioning service");
            /* Rearm one shot timeout timer */
            QTimeEvt_rearm(&me->timeoutEvt, PROVISION_TIMEOUT);
            /* start provisioning service */
            retval = doWork(Prov_start_service);
            if(retval != ESP_OK) {
                pEvt = Q_NEW(QEvt, PROV_SERVICE_START_FAILED_SIG);
                QACTIVE_POST(me->pParent, pEvt, me);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "SERVICE_ACTIVE: Exit");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE::PROV_SERVICE_START_FAILED} */
        case PROV_SERVICE_START_FAILED_SIG: {
            ESP_LOGE(TAG, "Failed to create worker thread for Prov_start_service");
            status_ = Q_TRAN(&Provision_INACTIVE);
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE::PROV_SERVICE_STOPPED} */
        case PROV_SERVICE_STOPPED_SIG: {
            ESP_LOGI(TAG, "Provisioning service stopped");
            status_ = Q_TRAN(&Provision_INACTIVE);
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE::PROV_SERVICE_STARTED} */
        case PROV_SERVICE_STARTED_SIG: {
            ESP_LOGI(TAG, "Provisioning service started");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE::SERVICE_ACTIVE::PROV_SERVICE_TIMEOUT} */
        case PROV_SERVICE_TIMEOUT_SIG: {
            ESP_LOGI(TAG, "Stopping Provision Service");
            doWork(Prov_stop_service);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Provision_ACTIVE);
            break;
        }
    }
    return status_;
}
/*$enddef${components::SystemManagement::components::provision::Provision} ^*/
