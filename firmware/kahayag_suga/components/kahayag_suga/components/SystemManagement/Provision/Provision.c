/*$file${components::SystemManagement::components::provision::.::Provision.c} */
/*
* Model: kahayag_suga.qm
* File:  ${components::SystemManagement::components::provision::.::Provision.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${components::SystemManagement::components::provision::.::Provision.c} */
#include "qpc.h"
#include "signalList.h"
#include "Provision.h"
#include "Wifi.h"
#include "worker.h"

#include "esp_log.h"
#include "esp_wifi.h"
#include "protocomm.h"
#include "wifi_provisioning/wifi_config.h"

#include "string.h"

/*$declare${components::SystemManagement::components::provision::Provision} */
/*${components::SystemManagement::components::provision::Provision} ........*/
typedef struct {
/* protected: */
    QHsm super;

/* private: */
    QHsm * pParent;
    protocomm_t * pcHdlr;
    int security;
    const protocomm_security_pop_t * pop;
    wifi_prov_sta_fail_reason_t wifi_disconnect_reason;
    char ssid[MAX_PROV_SSID_LEN + 1];
    char password[MAX_PROV_PASS_LEN+1];
} Provision;

/* protected: */
static QState Provision_initial(Provision * const me, QEvt const * const e);
static QState Provision_TOP(Provision * const me, QEvt const * const e);
static QState Provision_INACTIVE(Provision * const me, QEvt const * const e);
static QState Provision_ACTIVE(Provision * const me, QEvt const * const e);
/*$enddecl${components::SystemManagement::components::provision::Provision} */

Provision l_Provision;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${components::SystemManagement::components::provision::TAG} vvvvvvv*/
/*${components::SystemManagement::components::provision::TAG} ..............*/
static const char * TAG ="PROV_QHSM";
/*$enddef${components::SystemManagement::components::provision::TAG} ^^^^^^^*/

/*$define${components::SystemManagement::components::provision::Prov_ctor} v*/
/*${components::SystemManagement::components::provision::Prov_ctor} ........*/
QHsm * Prov_ctor(QHsm * parent) {
    static uint8_t bInitDone = (uint8_t)0;
    Provision *me;
    uint32_t idx;

    if(bInitDone == (uint8_t)0) {
        me = &l_Provision;
        /* Call constructor */
        QHsm_ctor(&me->super, Q_STATE_CAST(&Provision_initial));

        /* Call orthogonal Component constructor */

        /* Call Timer Constructor */

        /* Initialize members */
        me->pParent = parent;
        me->pcHdlr = NULL;
        me->security = 0;
        me->pop = NULL;
        memset(me->ssid, 0, sizeof(me->ssid));
        snprintf(me->ssid, MAX_PROV_SSID_LEN, "SUGA_XXXXXX");
        memset(me->password, 0, sizeof(me->password));
        snprintf(me->password, MAX_PROV_PASS_LEN, "password123");

        bInitDone = (uint8_t)1;
    }

    return(&me->super);
}
/*$enddef${components::SystemManagement::components::provision::Prov_ctor} ^*/
/*$define${components::SystemManagement::components::provision::Prov_EventHandler} */
/*${components::SystemManagement::components::provision::Prov_EventHandler} */
static esp_err_t Prov_EventHandler(void * ctx, system_event_t * event) {
    Provision * me = &l_Provision;

    /* For accessing reason codes in case of disconnection */
    system_event_info_t *info = &event->event_info;

    /* If pointer to provisioning application data is NULL
     * then provisioning is not running, therefore return without
     * error */
    //if (!g_prov) {
    //    return ESP_OK;
    //}

    switch(event->event_id) {
    case SYSTEM_EVENT_STA_START:
        ESP_LOGI(TAG, "STA Start");
        /* Once configuration is received by protocomm server,
         * device is restarted as both AP and Station.
         * Once station starts, wait for connection to
         * establish with configured host SSID and password */
    //    g_prov->wifi_state = WIFI_PROV_STA_CONNECTING;
        break;

    case SYSTEM_EVENT_STA_GOT_IP:
        ESP_LOGI(TAG, "STA Got IP");
        /* Station got IP. That means configuraion is successful.
         * Schedule timer to stop provisioning app after 30 seconds. */
    //    g_prov->wifi_state = WIFI_PROV_STA_CONNECTED;
    //    if (g_prov && g_prov->timer) {
            /* Note that, after restarting the WiFi in Station + AP mode, the
             * user gets disconnected from the AP for a while. But at the same
             * time, the user app requests for status update from the device
             * to verify that the provisioning was successful. Therefore, the
             * turning off of the AP must be delayed long enough for the user
             * to reconnect and get STA connection status from the device.
             * Otherwise, the AP will be turned off before the user can
             * reconnect and thus the user app will see connection timed out,
             * signalling a failure in provisioning. */
    //        esp_timer_start_once(g_prov->timer, 30000*1000U);
    //    }
        break;

    case SYSTEM_EVENT_STA_DISCONNECTED:
        ESP_LOGE(TAG, "STA Disconnected");
        /* Station couldn't connect to configured host SSID */
    //    g_prov->wifi_state = WIFI_PROV_STA_DISCONNECTED;
        ESP_LOGE(TAG, "Disconnect reason : %d", info->disconnected.reason);

        /* Set code corresponding to the reason for disconnection */
        switch (info->disconnected.reason) {
        case WIFI_REASON_AUTH_EXPIRE:
        case WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT:
        case WIFI_REASON_BEACON_TIMEOUT:
        case WIFI_REASON_AUTH_FAIL:
        case WIFI_REASON_ASSOC_FAIL:
        case WIFI_REASON_HANDSHAKE_TIMEOUT:
            ESP_LOGI(TAG, "STA Auth Error");
            me->wifi_disconnect_reason = WIFI_PROV_STA_AUTH_ERROR;
            break;
        case WIFI_REASON_NO_AP_FOUND:
            ESP_LOGI(TAG, "STA AP Not found");
            me->wifi_disconnect_reason = WIFI_PROV_STA_AP_NOT_FOUND;
            break;
        default:
            /* If none of the expected reasons,
             * retry connecting to host SSID */
    //        g_prov->wifi_state = WIFI_PROV_STA_CONNECTING;
    //        esp_wifi_connect();
            break;
        }
        break;

    default:
        break;
    }
    return ESP_OK;
}
/*$enddef${components::SystemManagement::components::provision::Prov_EventHandler} */
/*$define${components::SystemManagement::components::provision::Prov_start_wifi_ap} */
/*${components::SystemManagement::components::provision::Prov_start_wifi_ap} */
static void Prov_start_wifi_ap(void) {
    uint8_t eth_mac[6];
    esp_err_t err = ESP_OK;
    Provision *me = &l_Provision;
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();

    /* Initialise WiFi with default configuration */
    err = esp_wifi_init(&cfg);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to init WiFi : %d", err);
        return;
    }

    /* Set Wifi mode to AP */
    ESP_LOGI(TAG, "Set WiFi mode to AP");
    err = esp_wifi_set_mode(WIFI_MODE_AP);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi mode : %d", err);
        return;
    }

    /* SSID is based on MAC */
    err = esp_wifi_get_mac(WIFI_IF_STA, eth_mac);
    if(err != ESP_OK) {
        ESP_LOGE(TAG, "Error in getting mac: %d", err);
    } else {
        snprintf(me->ssid, MAX_PROV_SSID_LEN, "SUGA_%02X%02X%02X",
                eth_mac[3], eth_mac[4], eth_mac[5]);
    }

    /* Build WiFi configuration for AP mode */
    wifi_config_t wifi_config = {
        .ap = {
            .max_connection = 5,
        },
    };

    strncpy((char *) wifi_config.ap.ssid, me->ssid, sizeof(wifi_config.ap.ssid));
    wifi_config.ap.ssid_len = strlen(me->ssid);

    if (strlen(me->password) == 0) {
        memset(wifi_config.ap.password, 0, sizeof(wifi_config.ap.password));
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    } else {
        strncpy((char *) wifi_config.ap.password, me->password, sizeof(wifi_config.ap.password));
        wifi_config.ap.authmode = WIFI_AUTH_WPA_WPA2_PSK;
    }

    /* Start WiFi in AP mode with configuration built above */
    ESP_LOGI(TAG, "Configure WiFi AP");
    err = esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set WiFi config : %d", err);
        return;
    }
    ESP_LOGI(TAG, "Start WiFi");
    err = esp_wifi_start();
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start WiFi : %d", err);
        return;
    }

}
/*$enddef${components::SystemManagement::components::provision::Prov_start_wifi_ap} */

/*$define${components::SystemManagement::components::provision::Provision} v*/
/*${components::SystemManagement::components::provision::Provision} ........*/
/*${components::SystemManagement::components::provision::Provision::SM} ....*/
static QState Provision_initial(Provision * const me, QEvt const * const e) {
    /*${components::SystemManagement::components::provision::Provision::SM::initial} */

    QS_FUN_DICTIONARY(&Provision_TOP);
    QS_FUN_DICTIONARY(&Provision_INACTIVE);
    QS_FUN_DICTIONARY(&Provision_ACTIVE);

    return Q_TRAN(&Provision_TOP);
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP} */
static QState Provision_TOP(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Provision_INACTIVE);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE} */
static QState Provision_INACTIVE(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "INACTIVE entry");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE} */
        case Q_EXIT_SIG: {
            ESP_LOGI(TAG, "INACTIVE exit");
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::INACTIVE::START_PROVISION} */
        case START_PROVISION_SIG: {
            status_ = Q_TRAN(&Provision_ACTIVE);
            break;
        }
        default: {
            status_ = Q_SUPER(&Provision_TOP);
            break;
        }
    }
    return status_;
}
/*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE} */
static QState Provision_ACTIVE(Provision * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE} */
        case Q_ENTRY_SIG: {
            esp_err_t retval = ESP_OK;

            ESP_LOGI(TAG, "ACTIVE: entry");

            ESP_LOGI(TAG, "Starting WiFi SoftAP provisioning");
            ESP_ERROR_CHECK(Wifi_AddHook(Prov_EventHandler));

            /* Start Provisioning */
            retval = doWork(Prov_start_wifi_ap);
            if(retval != ESP_OK) {
                ESP_LOGE(TAG, "Failed on starting wifi ap");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*${components::SystemManagement::components::provision::Provision::SM::TOP::ACTIVE} */
        case Q_EXIT_SIG: {
            ESP_ERROR_CHECK(Wifi_RemoveHook(Prov_EventHandler));
            ESP_LOGI(TAG, "ACTIVE exit");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Provision_TOP);
            break;
        }
    }
    return status_;
}
/*$enddef${components::SystemManagement::components::provision::Provision} ^*/
