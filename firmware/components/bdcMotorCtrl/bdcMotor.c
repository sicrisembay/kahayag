/*$file${.::bdcMotor.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: bdcMotor.qm
* File:  ${.::bdcMotor.c}
*
* This code has been generated by QM 4.5.0 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*$endhead${.::bdcMotor.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "priorityList.h"
#include "signalList.h"
#include "bdcMotor.h"
#include "encoder/encoder.h"
#include "motor_driver/motor_driver.h"
#include "esp_log.h"

Q_DEFINE_THIS_FILE

static const char *TAG = "bdcMotor";

/* Motor Task Priority Configuration (MOTOR ID to Priority translation) */
static UBaseType_t const MOTOR_PRIORITY[MOTOR_ID_MAX] = {
    PRIORITY_MOTOR_ONE,
    PRIORITY_MOTOR_TWO,
    PRIORITY_MOTOR_THREE,
    PRIORITY_MOTOR_FOUR,
};

/* Motor Encoder Configuration (MOTOR ID to ENCODER ID translation) */
static encoder_id_t const MOTOR_ENCODER[MOTOR_ID_MAX] = {
    ENCODER_ID_1,   // MOTOR_ONE uses ENCODER_ID_1
    ENCODER_ID_2,   // MOTOR_TWO uses ENCODER_ID_2
    ENCODER_ID_3,   // MOTOR_THREE uses ENCODER_ID_3
    ENCODER_ID_4    // MOTOR_FOUR uses ENCODER_ID_4
};

/* Motor Driver Configuration (MOTOR ID to DRIVER ID translation) */
static motor_driver_id_t const MOTOR_DRIVER[MOTOR_ID_MAX] = {
    MOTOR_DRIVER_ID_1,  // MOTOR_ONE uses MOTOR_DRIVER_ID_1
    MOTOR_DRIVER_ID_2,  // MOTOR_TWO uses MOTOR_DRIVER_ID_2
    MOTOR_DRIVER_ID_3,  // MOTOR_THREE uses MOTOR_DRIVER_ID_3
    MOTOR_DRIVER_ID_4   // MOTOR_FOUR uses MOTOR_DRIVER_ID_4
};

/*$declare${bdcMotor::bdcMotor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${bdcMotor::bdcMotor} ....................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt ctrlTimeEvt;
    encoder_id_t encoderId;
    motor_driver_id_t driverId;
    fix16_t q16_dutyCycle;
} bdcMotor;

/* protected: */
static QState bdcMotor_initial(bdcMotor * const me, QEvt const * const e);
static QState bdcMotor_TOP(bdcMotor * const me, QEvt const * const e);
static QState bdcMotor_NORMAL(bdcMotor * const me, QEvt const * const e);
static QState bdcMotor_STOPPED(bdcMotor * const me, QEvt const * const e);
static QState bdcMotor_RUNNING(bdcMotor * const me, QEvt const * const e);
static QState bdcMotor_STOPPING(bdcMotor * const me, QEvt const * const e);
static QState bdcMotor_ERROR(bdcMotor * const me, QEvt const * const e);
/*$enddecl${bdcMotor::bdcMotor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Local Object */
static bdcMotor l_bdcMotor[MOTOR_ID_MAX];
/* helper macro to provide the ID of motor "me_" */
#define MOTOR_ID(me_)    ((uint8_t)((me_) - l_bdcMotor))

static QEvt const l_bdcMotorQSto[MOTOR_ID_MAX][64];
/* FreeRTOS stack for AO */
static StackType_t bdcMotorStack[MOTOR_ID_MAX][CONFIG_MOTOR_STACK_SIZE];

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${bdcMotor::AO_bdcMotor[MOTOR_ID_MAX]} vvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/* opaque pointer to motor Active Object */
/*${bdcMotor::AO_bdcMotor[MOTOR_ID_MAX]} ...................................*/
QActive * const AO_bdcMotor[MOTOR_ID_MAX] = {
    &l_bdcMotor[MOTOR_ID_ONE].super,
    &l_bdcMotor[MOTOR_ID_TWO].super,
    &l_bdcMotor[MOTOR_ID_THREE].super,
    &l_bdcMotor[MOTOR_ID_FOUR].super,
};
/*$enddef${bdcMotor::AO_bdcMotor[MOTOR_ID_MAX]} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${bdcMotor::bdc_motor_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${bdcMotor::bdc_motor_ctor} ..............................................*/
void bdc_motor_ctor(void) {
    static uint32_t bInitDone = (uint32_t)0;
    uint32_t id = 0;
    bdcMotor *me;
    char taskName[16];

    if(!bInitDone) {
        /* initialize encoder */
        encoder_init();
        /* initialize motor driver */
        motor_driver_init();

        for(id = 0; id < MOTOR_ID_MAX; id++) {
            me=&l_bdcMotor[id];
            /* Call constructors */
            QActive_ctor(&me->super, Q_STATE_CAST(&bdcMotor_initial));
            QTimeEvt_ctorX(&me->ctrlTimeEvt, &me->super, BDC_MOTOR_CTRL_TIMEOUT_SIG, 0U);

            /* Initialize Members */
            me->encoderId = MOTOR_ENCODER[id];
            me->driverId = MOTOR_DRIVER[id];
            me->q16_dutyCycle = (fix16_t)0;

            /* Start active object */
            sprintf(taskName, "AO_MOT%02d", id);
            QActive_setAttr(AO_bdcMotor[id], TASK_NAME_ATTR, taskName);
            QACTIVE_START(
                AO_bdcMotor[id],
                MOTOR_PRIORITY[id],
                l_bdcMotorQSto[id],
                Q_DIM(l_bdcMotorQSto[id]),
                bdcMotorStack[id],
                sizeof(bdcMotorStack[id]),
                (QEvt *)0);
        }
        bInitDone = (uint32_t)1;
    }
}
/*$enddef${bdcMotor::bdc_motor_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${bdcMotor::bdcMotor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${bdcMotor::bdcMotor} ....................................................*/
/*${bdcMotor::bdcMotor::SM} ................................................*/
static QState bdcMotor_initial(bdcMotor * const me, QEvt const * const e) {
    /*${bdcMotor::bdcMotor::SM::initial} */
    // Arm Timer for periodic generation of events
    QTimeEvt_armX(&me->ctrlTimeEvt, CONFIG_MOTOR_CTRL_INTERVAL, CONFIG_MOTOR_CTRL_INTERVAL);
    return Q_TRAN(&bdcMotor_TOP);
}
/*${bdcMotor::bdcMotor::SM::TOP} ...........................................*/
static QState bdcMotor_TOP(bdcMotor * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${bdcMotor::bdcMotor::SM::TOP} */
        case Q_ENTRY_SIG: {
            ESP_LOGI(TAG, "Entry Mot%02d", MOTOR_ID(me));
            status_ = Q_HANDLED();
            break;
        }
        /*${bdcMotor::bdcMotor::SM::TOP::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&bdcMotor_NORMAL);
            break;
        }
        /*${bdcMotor::bdcMotor::SM::TOP::BDC_MOTOR_CTRL_TIMEOUT} */
        case BDC_MOTOR_CTRL_TIMEOUT_SIG: {
            /* calculate/Update encoder rate */
            encoder_update(me->encoderId);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${bdcMotor::bdcMotor::SM::TOP::NORMAL} ...................................*/
static QState bdcMotor_NORMAL(bdcMotor * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${bdcMotor::bdcMotor::SM::TOP::NORMAL::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&bdcMotor_STOPPED);
            break;
        }
        default: {
            status_ = Q_SUPER(&bdcMotor_TOP);
            break;
        }
    }
    return status_;
}
/*${bdcMotor::bdcMotor::SM::TOP::NORMAL::STOPPED} ..........................*/
static QState bdcMotor_STOPPED(bdcMotor * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&bdcMotor_NORMAL);
            break;
        }
    }
    return status_;
}
/*${bdcMotor::bdcMotor::SM::TOP::NORMAL::RUNNING} ..........................*/
static QState bdcMotor_RUNNING(bdcMotor * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&bdcMotor_NORMAL);
            break;
        }
    }
    return status_;
}
/*${bdcMotor::bdcMotor::SM::TOP::NORMAL::STOPPING} .........................*/
static QState bdcMotor_STOPPING(bdcMotor * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&bdcMotor_NORMAL);
            break;
        }
    }
    return status_;
}
/*${bdcMotor::bdcMotor::SM::TOP::ERROR} ....................................*/
static QState bdcMotor_ERROR(bdcMotor * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&bdcMotor_TOP);
            break;
        }
    }
    return status_;
}
/*$enddef${bdcMotor::bdcMotor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
